= Test-Plan

Dieser Testplan stellt eine vereinfachte Version der IEEE 829-1998 Vorlage dar.

== Einführung
Der Testplan wird erstellt, um den Testprozess unserer Anwendung zu beschreiben und folgende Aspekte zu klären:

- die Auswahl der richtigen Strategien für verschiedene Tests von Software-Komponenten
- Verteilung der Aufgaben zwischen den Teammitgliedern
- Priorität der Fragen
- Ressourcenplanung
- die Nutzung der erforderlichen Software und Hardware
- Abschätzung der Risiken, die während der Prüfung auftreten können.

== Aufbau der Testbezeichner

U = Unit Test:

- prüft Einzelteile eines Computerprogrammes auf Funktionalität

I = Integrationstest:

- eine Reihe von aufeinander abgestimmten Einzeltests, die dazu dienen, verschiedene voneinander abhängige Komponenten eines komplexen Systems im Zusammenspiel miteinander zu testen
- die einzelnen Komponenten sollten einen Unit-Test bestanden haben

zum Beispiel: U1, U2, I1

== Test Gegenstände
Die gesamte Anwendung von McTank bestehend aus 

- McZapf 
- McWash 
- McSit 
- McDrive 
- registrierter Kunde 
- nicht registrierter Kunde 
- Manager 
- Mitarbeiter 
- Catalog 
- Inventory 
- Order 


== Zu testende Funktionalitäten
- Registrierung <<U1>>
- Benzinbestellung <<U2>>
- Rabatt <<U3>>
- Altersabfrage <<U4>>
- Login/Logout <<U5>>
- Reservierung <<U6>>
- Bezahlvorgang <<U7>>
- Items werden vollständig angezeigt <<I1>>
- User sind korrekt autorisiert <<I2>>

== Nicht zu testende Funktionalitäten
z.B. Bibliotheken von Drittanbietern (eigene Tests beschränken sich auf Schnittstelle, bzw. Zusammenspiel).

- Daten der Zapfsäulen
- gegebene Bibliotheken oder Frameworks

== Herangehensweise
Die Units bzw. Klassen werden mit JUnit getestet.
Die Testfälle werden vor dem Code entwickelt, damit nur Dinge implementiert werden, die auch getestet werden können, um somit Fehler beim Programmieren zu vermeiden.

1. Testfälle ausdenken / Testfalltabellen erstellen
- Bestimme die Extremwerte der Parameter der zu testenden Methode (Grenzwertanalyse, Nullwerte immer testen, z.B. 0 oder null, Randwerte z.B. 1.1. und 31.12.)
- Bestimme Bereichseinschränkungen (Werte außerhalb eines Zahlenbereiches, Negative Werte, wenn natürliche Zahlen im Spiel sind)
- Bestimme Zustände, in denen sich ein Objekt nach einer Anweisung befinden muss
2. Testfälle in Klassen gruppieren
3. pro Testfall eine Testmethode schreiben
4. Testfälle (nach Änderungen im Programm wiederholt) ausführen = Regressionstest

== Umgebungsvoraussetzungen
* Wird spezielle Hardware benötigt?

- keine spezielle Hardware, die Tests werden mit in das eigentliche Programm integriert
* Welche Daten müssen bereitgestellt werden? Wie werden die Daten bereitgestellt?
- es wird ein automatisch wiederholbarer JUnit-Test geschrieben und dann der zu testende Code. Der Test ist selbst ein Stück Software und wird ebenso wie der zu testende Code programmiert.
* Wird zusätzliche Software für das Testen benötigt?

- jUnit

* Wie kommuniziert die Software während des Testens? Internet? Netzwerk?
- 

== Testfälle und Verantwortlichkeit
Jede testbezogene Aufgabe muss einem Ansprechpartner zugeordnet werden.

== MainControllerTest
// See http://asciidoctor.org/docs/user-manual/#tables
[options="headers"]
|===
|ID   |Anwendungsfall |Vorbedingungen |Eingabe |Ausgabe
||HTML-Seitenaufruf            |Eine Seite wird von einem User aufgerufen| mockMvc.perform(get("/"))     |.andExpect(status().isFound())
||Login-Aufruf           | Falls ein nicht eingeloggter User auf die Anwendung zugreifen will, wird er auf die Login-Page geleitet             |mockMvc.perform(get("/")) |.andExpect(status().isFound()).andExpect(redirectedUrl("/login")
||Admin-Startseite | Ein User loggt sich als Admin auf der Website ein             |mockMvc.perform(get("/")) |.andExpect(status().isFound()).andExpect(redirectedUrl("/overview")
|| Mitarbeiter-Startseite          |Ein User loggt sich als Mitarbeiter auf der Website ein              |mockMvc.perform(get("/")) |.andExpect(status().isFound()).andExpect(redirectedUrl("/cart"))
|| Customer-Startseite          | Ein User loggt sich als Kunde auf der Website ein             |mockMvc.perform(get("/")) |.andExpect(status().isFound()).andExpect(redirectedUrl("/account"))
|===

== RefillInventoryControllerTest
// See http://asciidoctor.org/docs/user-manual/#tables
[options="headers"]
|===
||Inventar wird aufgefüllt           |Es soll Benzin nachbestellt werden              |		RequestFuelBody requestFuelBody = new RequestFuelBody();
		requestFuelBody.setAmount(10);
		requestFuelBody.setFuelType(GasPump.DIESEL); |		assertEquals(controller.refillFuels(requestFuelBody), ResponseEntity.ok().build());
|===

== UserManagementControllerTest
// See http://asciidoctor.org/docs/user-manual/#tables
[options="headers"]
|===
||User-Management           | Es soll eine Liste aller User angezeigt werden, welche sich bearbeiten lässt             |mockMvc.perform(get("/user-management")) |.andExpect(status().isOk())
				.andExpect(view().name("user-management"))
				.andExpect(model().attributeExists("customerList"));
||User-Status aktivieren         | Ein Useraccount und seine damit verbundenen Funktionalitäten kann aktiviert werden             |mockMvc.perform(get("/customer/disable")) |				.andExpect(status().isFound());
||User-Status deaktivieren          | Ein Useraccount und seine damit verbundenen Funktionalitäten kann deaktiviert werden             |		mockMvc.perform(get("/customer/enable")) |				.andExpect(status().isFound());
|===

== ItemsControllerTest
// See http://asciidoctor.org/docs/user-manual/#tables
[options="headers"]
|===
||           |              | |
||           |              | |
||           |              | |
||           |              | |
||           |              | |

|===
